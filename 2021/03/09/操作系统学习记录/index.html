<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/change_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/change_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"git-liweichao.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一讲 操作系统概述操作系统定义 操作系统是一个控制程序  一个系统软件 控制程序执行过程，防止错误和计算机的不当使用 执行用户程序，给用户程序提供各种服务 方便用户使用计算机系统   操作系统对硬件进行一层隔离，对上面的应用提供我们通常所见到的逻辑这些资源，比如说进程、文件、地址空间   1234567graph TD;	软件--&gt;应用软件;	软件--&gt;系统软件;	系统软件--&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习记录">
<meta property="og:url" content="http://git-liweichao.github.io/2021/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="MyShare">
<meta property="og:description" content="第一讲 操作系统概述操作系统定义 操作系统是一个控制程序  一个系统软件 控制程序执行过程，防止错误和计算机的不当使用 执行用户程序，给用户程序提供各种服务 方便用户使用计算机系统   操作系统对硬件进行一层隔离，对上面的应用提供我们通常所见到的逻辑这些资源，比如说进程、文件、地址空间   1234567graph TD;	软件--&gt;应用软件;	软件--&gt;系统软件;	系统软件--&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-09T15:07:53.000Z">
<meta property="article:modified_time" content="2021-04-02T11:17:34.859Z">
<meta property="article:author" content="liweichao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://git-liweichao.github.io/2021/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统学习记录 | MyShare</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MyShare</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-playlist">

    <a href="/playlist/" rel="section"><i class="music fa-fw"></i>playlist</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://git-liweichao.github.io/2021/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/clannad.jpg">
      <meta itemprop="name" content="liweichao">
      <meta itemprop="description" content="If you are not as smart as others, as others good conditions, please put more time! more energy! more sweat!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MyShare">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统学习记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 15:07:53" itemprop="dateCreated datePublished" datetime="2021-03-09T15:07:53Z">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 11:17:34" itemprop="dateModified" datetime="2021-04-02T11:17:34Z">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第一讲-操作系统概述"><a href="#第一讲-操作系统概述" class="headerlink" title="第一讲 操作系统概述"></a>第一讲 操作系统概述</h2><h4 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h4><ul>
<li><p>操作系统是一个控制程序</p>
<ul>
<li>一个<strong>系统软件</strong></li>
<li>控制程序执行过程，防止错误和计算机的不当使用</li>
<li>执行用户程序，给用户程序提供各种服务</li>
<li>方便用户使用计算机系统</li>
</ul>
</li>
<li><p>操作系统对硬件进行一层隔离，对上面的应用提供我们通常所见到的逻辑这些资源，比如说进程、文件、地址空间</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	软件--&gt;应用软件;</span><br><span class="line">	软件--&gt;系统软件;</span><br><span class="line">	系统软件--&gt;系统应用;</span><br><span class="line">	系统软件--&gt;操作系统;</span><br><span class="line">	操作系统--&gt;命令行;</span><br><span class="line">	操作系统--&gt;内核;</span><br></pre></td></tr></table></figure>


<p>操作系统内核特征：并发、共享、虚拟、异步；</p>
<ul>
<li>并发：<ul>
<li>计算机系统中同时存在多个运行的程序，需要OS管理和调度</li>
</ul>
</li>
<li>共享：<ul>
<li>我们多个应用并发进行的时候，宏观上要体现出它们在同时访问资源的情况，微观上要体现它们的互斥访问。</li>
</ul>
</li>
<li>虚拟：<ul>
<li>利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务，交替的频率非常高，让用户在用的时候感觉不太出来这台机器还有其他用户还在使用。</li>
</ul>
</li>
<li>异步：<ul>
<li>程序的执行不是一贯到底，而是走走停停的，向前推进的速度不可预知。只要运行环境相同，OS需要保证程序运行的结果也要相同。</li>
</ul>
</li>
</ul>
<h3 id="第三讲-启动、中断和系统调用"><a href="#第三讲-启动、中断和系统调用" class="headerlink" title="第三讲 启动、中断和系统调用"></a>第三讲 启动、中断和系统调用</h3><h4 id="3-1-BIOS-Basic-Input-Output-System"><a href="#3-1-BIOS-Basic-Input-Output-System" class="headerlink" title="3.1 BIOS(Basic Input  Output System)"></a>3.1 BIOS(Basic Input  Output System)</h4><ul>
<li>BIOS位于空闲空间的再往上的一部分，处于640KB~1MB的位置。</li>
<li>BIOS提供的基本服务：<ul>
<li>基本输入输出的程序</li>
<li>系统设置信息</li>
<li>开机后自检程序</li>
<li>系统自启动程序等</li>
</ul>
</li>
<li>BIOS将加载程序从磁盘的引导扇区（512字节）加载到0x7c00，然后跳转到CS:IP = 0000:7c00。<ul>
<li>这里加载程序的作用是<strong>将操作系统的代码和数据从硬盘加载到内存中，跳转到操作系统的起始位置，控制权交给操作系统</strong></li>
</ul>
</li>
<li>为什么不直接从BIOS里头把操作系统的内核加载进来？<ul>
<li>磁盘上有各种各样的文件系统，机器出厂时候不可以直接限制死只使用某一种文件系统。而且为了<strong>增加灵活性</strong>，在BIOS里头不可能加上认识所有文件系统代码。因此有一个基本的约定，我不需要认识格式也能从硬盘里头读取到第一块，再用加载程序来识别硬盘上的文件系统。</li>
</ul>
</li>
<li>BIOS以中断调用的方式提供了基本的I/O功能，在x86系统限制在实模式下工作</li>
</ul>
<h4 id="3-2-系统启动流程"><a href="#3-2-系统启动流程" class="headerlink" title="3.2 系统启动流程"></a>3.2 系统启动流程</h4><ul>
<li><p>首先是系统加电BIOS初始化，然后BIOS读取主引导扇区代码，主引导扇区代码夺取活动分区的引导扇区代码，引导扇区代码读取文件系统的加载程序。</p>
</li>
<li><p>下面是对每一个部分的各自功能简要概述</p>
<ul>
<li>系统加电后，BIOS初始化相关的硬件，包括（硬件自检POST最关键的那几部分），系统检测（检测和配置系统中安装的即插即用的设备）。更新CMSO中的扩展系统配置数ESCD（扩展系统配置数据比如说U盘、硬盘）。</li>
<li>主引导记录（MBR）<ul>
<li>启动代码：446字节<ul>
<li>检查分区表正确性</li>
<li>加载并跳转到磁盘上的引导程序（活动分区）</li>
</ul>
</li>
<li>硬盘分区表：64字节<ul>
<li>描述分区状态和位置</li>
<li>每个分区描述信息占据16字节</li>
</ul>
</li>
<li>结束标志字：2字节（55AA），主引导记录的有效标志</li>
</ul>
</li>
<li>之后跳到活动分区的引导扇区上<ul>
<li>跳转指令：跳转到启动代码（与平台相关代码）</li>
<li>文件卷头：文件系统描述信息</li>
<li>启动代码：跳转到加载程序（靠这里的代码约定加载程序在磁盘上的位置）</li>
<li>结束标志：55AA</li>
</ul>
</li>
<li>加载程序（BootLoader）<ul>
<li>加载程序是能够认识文件系统格式的，首先是去读取启动配置文件（该文件在不同的操作中是不同的，可以选择启动的模式比如说正常启动、安全启动、调试状态下的启动）。</li>
<li>根据配置加载内核。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用BIOS-GPT就不会受到只能4个分区的限制了。PXE是网络启动的标准，从网络中加载内核镜像。</p>
</li>
<li><p>操作系统启动过程的简要描述</p>
<ul>
<li>系统的内存主要分成两种，一种是RAM（随机存储器），一种是ROM（只读存储器，只有1MB）。ROM是非易失性的，在电脑断电后还是可以保存的。所以当电脑启动的时候就是从ROM开始读的，并且我们所熟知的<strong>BIOS</strong>就存放在ROM中。在电脑加电的时候电脑是处于<strong>实模式</strong>，此时的地址总线是20位的，这也就解释了IMB的起始空间。启动的时候会通过段寄存器CS(段寄存器)+IP(当前指针)地址指针指向BIOS的地址，从BIOS的地方开始执行。</li>
</ul>
</li>
</ul>
<h4 id="3-3-中断、异常和系统调用比较"><a href="#3-3-中断、异常和系统调用比较" class="headerlink" title="3.3 中断、异常和系统调用比较"></a>3.3 中断、异常和系统调用比较</h4><ul>
<li>系统调用（System call）<ul>
<li>应用程序<strong>主动</strong>向操作系统发出的服务请求</li>
<li>源头：应用程序请求操作系统提供服务</li>
<li>响应方式：异步或同步</li>
<li>处理机制：等待和持续</li>
</ul>
</li>
<li>异常（exception）<ul>
<li>非法指令或者其他原因导致当前的<strong>指令执行失败</strong>（如：内存出错）后的处理请求</li>
<li>源头：应用程序意向不到的行为</li>
<li>响应方式：同步</li>
<li>处理机制：杀死或者重新执行意向不到的应用程序指令</li>
</ul>
</li>
<li>中断（hardware interrupt）<ul>
<li>来自硬件设备的处理请求。</li>
<li>源头：外设</li>
<li>响应方式：异步</li>
<li>处理机制：持续，对用户应用程序时透明的</li>
</ul>
</li>
</ul>
<h4 id="3-4-系统调用"><a href="#3-4-系统调用" class="headerlink" title="3.4 系统调用"></a>3.4 系统调用</h4><ul>
<li>系统调用是操作系统对上提供服务的接口，每个系统调用对应一个系统调用号<ul>
<li>系统调用接口根据系统调用号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中的系统调用功能事先，并返回系统调用的状态和结果</li>
<li>系统调用和函数调用的区别：<ul>
<li>INT和IRET指令用于系统调用<ul>
<li>系统调用时，堆栈切换和特权级的转换</li>
</ul>
</li>
<li>CALL和RET用于函数调用<ul>
<li>函数调用时，没有堆栈切换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第四讲-实验一-bootloader启动ucore"><a href="#第四讲-实验一-bootloader启动ucore" class="headerlink" title="第四讲 实验一 bootloader启动ucore"></a>第四讲 实验一 bootloader启动ucore</h3><ul>
<li><p>ld (链接)，带有的参数的含义如下：</p>
<ul>
<li><p>-m:模拟对应的链接器（此处为i386）</p>
</li>
<li><p>-T：显式地向链接器提供命令文件（也叫连接器脚本）</p>
</li>
</ul>
</li>
</ul>
<h3 id="第五讲-物理内存管理：连续内存分配"><a href="#第五讲-物理内存管理：连续内存分配" class="headerlink" title="第五讲 物理内存管理：连续内存分配"></a>第五讲 物理内存管理：连续内存分配</h3><h4 id="5-1-计算机体系结构和内存层次"><a href="#5-1-计算机体系结构和内存层次" class="headerlink" title="5.1 计算机体系结构和内存层次"></a>5.1 计算机体系结构和内存层次</h4><ul>
<li>高速缓存<ul>
<li>CPU里面有高速缓存，如果有大量的数据需要读写且会要重复利用的话，加快读写速度，提升效率。</li>
</ul>
</li>
<li>存储管理单元（MMU），就把逻辑（虚拟）地址空间转变成物理地址空间。物理地址空间不一样，但是可能转换到逻辑地址空间是一样的。</li>
<li>想要实现的四个目的：<ul>
<li>抽象：<ul>
<li>逻辑地址空间</li>
</ul>
</li>
<li>保护：<ul>
<li>独立地址空间</li>
</ul>
</li>
<li>共享：<ul>
<li>访问相同内存</li>
</ul>
</li>
<li>虚拟化：<ul>
<li>更大的地址空间</li>
</ul>
</li>
</ul>
</li>
<li>操作系统的内存管理方式<ul>
<li>重定位（relocation）<ul>
<li>可以整块的搬，段地址加偏移的概念就是从这里得到的。</li>
</ul>
</li>
<li>分段（segmentation）<ul>
<li>每个进程分的存储空间是一个连续的空间，不可以把两个交错起来。至少可以分成<strong>数据、代码和堆栈</strong>。虽然如此，分段一段的内容也还是要连续的。</li>
</ul>
</li>
<li>分页（paging）<ul>
<li>把内存分成最基本的单位：比如说盖楼需要一块块的砖，一块块砖可以组成我们需要的形状。<strong>一个字节开销大，以至于管理的难度较高</strong>。</li>
</ul>
</li>
<li>虚拟存储（Virtual memory）<ul>
<li>目前多数系统（如Linux）采用按需页式虚拟存储。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-地址空间和地址生成"><a href="#5-2-地址空间和地址生成" class="headerlink" title="5.2 地址空间和地址生成"></a>5.2 地址空间和地址生成</h4><ul>
<li>物理地址空间–硬件支持的地址空间<ul>
<li>起始地址0，知道MAX<sub> sys</sub>。32位的话就是从0-(4G-1)的大小。</li>
</ul>
</li>
<li>逻辑地址空间–在CPU运行的进程看到的地址<ul>
<li>起始地址0，知道MAX<sub>prog</sub>。</li>
</ul>
</li>
<li>地址生成时机和限制存在三种情况<ul>
<li>编译时：<ul>
<li>假设起始地址已知</li>
<li>如果起始地址改变，必须重新编译</li>
</ul>
</li>
<li>加载时：<ul>
<li>如编译时起始位置未知，编译器需要生成可重定位的代码</li>
<li>加载时生成绝对地址</li>
</ul>
</li>
<li>执行时：<ul>
<li>执行时代码可移动</li>
<li>需地址转换（映射）硬件支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-连续内存分配"><a href="#5-3-连续内存分配" class="headerlink" title="5.3 连续内存分配"></a>5.3 连续内存分配</h4><ul>
<li>给进程分配一块不小于指定大小的连续的物理内存区域（包括代码、数据和堆栈）。</li>
<li>有些空闲内存是不能利用的，被称为<strong>内存碎片</strong></li>
<li>内存碎片主要分成两种，外部碎片和内部碎片<ul>
<li>分配单元之间的未被使用的内存，被称为<strong>外部碎片</strong>，由于其过小，其他进程申请的空间都比它大</li>
<li><strong>内部碎片</strong>，分配单元内部的未使用内存，取决于分配单元大小是否要取整</li>
</ul>
</li>
<li>动态分区分配：<ul>
<li>当程序被加载执行时，分配一个进程指定大小可变的分区（块、内存块）</li>
<li>分区的地址是连续的</li>
<li>操作系统需要维护当前所有进程的已分配分区，空闲分区</li>
<li>动态分区分配的策略有：<ul>
<li>最先匹配（First-fit）<ul>
<li>思路：分配n个字节，使用第一个可用的空间比n大的空闲块。</li>
<li>原理&amp;实现：<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配过程时，搜索第一个合适的分区</li>
<li>释放分区时，检查是否可与临近的空闲分区合并</li>
</ul>
</li>
<li>优点：<ul>
<li>简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
</li>
<li>缺点：<ul>
<li>外部碎片</li>
<li>分配大块时较慢</li>
</ul>
</li>
</ul>
</li>
<li>最佳匹配（Best-fit）<ul>
<li>思路：分配n字节分区时，查找并使用不小于n的最小空闲分区</li>
<li>原理&amp;实现：<ul>
<li>空闲分区列表按照大小排序</li>
<li>分配时，查找一个合适的分区</li>
<li>释放时，查找并且合并临近的空闲分区（如果找到），此时合并算法较复杂。</li>
</ul>
</li>
<li>优点：<ul>
<li>可避免大的空闲分区被拆分</li>
<li>可减小外部碎片的大小</li>
</ul>
</li>
<li>缺点：<ul>
<li>外部碎片</li>
<li>释放分区较慢</li>
<li>容易产生很多无用的小碎片</li>
</ul>
</li>
</ul>
</li>
<li>最差匹配（Worst-fit）<ul>
<li>思路：分配n字节，使用尺寸不小n的最大空闲分区</li>
<li>原理&amp;实现：<ul>
<li>空闲分区按列表由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序</li>
</ul>
</li>
<li>优点：<ul>
<li>中等大小的分配较多时，效果最好</li>
<li>避免出现太多的碎片</li>
</ul>
</li>
<li>缺点：<ul>
<li>释放分区较慢、外部碎片、容易破坏大的空闲分区，因此难以分配大的分区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-3-碎片整理"><a href="#5-3-碎片整理" class="headerlink" title="5.3 碎片整理"></a>5.3 碎片整理</h4><ul>
<li>碎片整理的概念：通过调整进程占用的分区位置来减少或避免分区碎片</li>
<li>碎片紧凑：<ul>
<li>通过移动分配给进程的内存分区，以合并外部碎片</li>
<li>执行条件是：所有的应用程序可以动态重定位</li>
<li>在应用程序等待的时候可以移动，不能是运行过程中</li>
</ul>
</li>
<li>在早期的时候将等待状态的内存移动到外存中，空闲出来的区域就可以让其他的进程运行</li>
</ul>
<h4 id="5-4-伙伴系统-Buddy-System"><a href="#5-4-伙伴系统-Buddy-System" class="headerlink" title="5.4 伙伴系统(Buddy System)"></a>5.4 伙伴系统(Buddy System)</h4><ul>
<li>以2的n次幂进行切块(如果比它的二倍大就切块)，并且当进程回收的时候相邻需要能够合成2的n次幂才能回收空间 注意<strong>合并条件</strong>:<ol>
<li>大小相同为2<sup>i</sup>   2. 地址相邻     3.起始地址较小的块的起始地址必须是2<sup>(i + 1)</sup>的倍数.</li>
</ol>
</li>
</ul>
<h3 id="第六讲-物理内存管理：非连续内存分配"><a href="#第六讲-物理内存管理：非连续内存分配" class="headerlink" title="第六讲 物理内存管理：非连续内存分配"></a>第六讲 物理内存管理：非连续内存分配</h3><h4 id="6-2-段式存储管理"><a href="#6-2-段式存储管理" class="headerlink" title="6.2 段式存储管理"></a>6.2 段式存储管理</h4><ul>
<li><p>进程的地址空间看作是若干个段组成的,比如说主代码段, 子模块段,堆栈段…….<strong>更细粒度和灵活的分离和共享</strong></p>
</li>
<li><p>段的概念:</p>
<ul>
<li><strong>段表示访问方式和存储数据等数据相同的一段地址空间</strong></li>
<li>对应一个连续的内存”块”</li>
<li><strong>若干个段组成进程逻辑地址空间</strong></li>
</ul>
</li>
<li><p>段访问: 逻辑地址由二元组(s, addr)表示</p>
<ul>
<li>s—段号</li>
<li>addr—段内偏移</li>
</ul>
</li>
<li><p>访问过程简要描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">逻辑地址--&gt;段号;</span><br><span class="line">逻辑地址--&gt;偏移;</span><br><span class="line">段号--&gt;段表中的段描述符;</span><br><span class="line">段表中的段描述符--&gt;基址;</span><br><span class="line">段表中的段描述符--&gt;长度;</span><br><span class="line">长度--&gt;MMU判断内存是否异常;</span><br><span class="line">偏移--&gt;MMU判断内存是否异常;</span><br><span class="line">MMU判断内存是否异常--&gt;访问对应部分;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-3-页式存储管理"><a href="#6-3-页式存储管理" class="headerlink" title="6.3 页式存储管理"></a>6.3 页式存储管理</h4></li>
<li><p>页帧(帧/物理页面/Frame, Page Frame)</p>
<ul>
<li>把<strong>物理地址</strong>空间划分为大小相同的基本分配单位</li>
<li>2的n次方,如512, 4096, 8192</li>
</ul>
</li>
<li><p>页面(页/逻辑页面/Page)</p>
<ul>
<li>把<strong>逻辑地址</strong>空间页划分为相同大小的基本分配单位</li>
<li><strong>帧和页的大小必须是相同的</strong></li>
</ul>
</li>
<li><p>逻辑地址空间的页号是连续的, 物理地址空间的帧号通常是不连续的</p>
</li>
<li><p>页表表示的是页面到页帧的转换, <strong>页面保存了逻辑地址和物理地址之间的映射关系</strong>. </p>
</li>
<li><p>映射过程简要概述:</p>
<ul>
<li>在逻辑地址空间中, 地址总线(32)位, 一部分用于表示页号, 一部分用于表示页内偏移. 使用页表基址+页面号就可以查到对应的页表项, 帧号f是里面的字段之一, 把帧号和页内偏移加在一起就可以得到对应的物理地址了(这里把f左移对应的位数加上偏移就可以实现了).</li>
</ul>
</li>
</ul>
<h4 id="6-4-页表概述"><a href="#6-4-页表概述" class="headerlink" title="6.4 页表概述"></a>6.4 页表概述</h4><ul>
<li><strong>每个进程都有一个页表</strong><ul>
<li>每个页面对应一个页表项</li>
<li>随进程运行状态而动态变化</li>
<li>页表基址寄存器（PTBR: Page Table Base Register ）用于存储页表的起始位置</li>
</ul>
</li>
<li><strong>页表项的组成</strong>：<ul>
<li>帧号：f</li>
<li>页表项标志：<ul>
<li>存在位：(resident bit)  是否有一个物理帧与其相对应</li>
<li>修改位：(dirty bit)</li>
<li>引用位：(clock/reference)  过去的一段时间是否有对它的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-5-快表和多级页表"><a href="#6-5-快表和多级页表" class="headerlink" title="6.5 快表和多级页表"></a>6.5 快表和多级页表</h4><ul>
<li>快表（Translation Look-aside Buffer TLB）就是把近期访问过的页表项，缓存到CPU里头。<ul>
<li>TLB使用关联存储(associative memory)实现，具备快速访问性能。<strong>就是在CPU中开辟出了一张表存有对应逻辑地址的key和对应物理地址的value，如果查到就可以直接跳转了</strong>。在CPU中速度比较快。</li>
<li>如果TLB命中，物理页号可以很快被获取</li>
<li>如果TLB未命中，对应的页表项被更新到TLB中</li>
</ul>
</li>
<li>多级页表是通过间接引用，将页号分成若干级<ul>
<li>建立页表“树”</li>
<li>减少每级页表的长度</li>
<li>eg 地址总线切成好几段，前面几段作为多级页表的不同位置</li>
<li>CR3寄存器存储第一级的起始位置</li>
</ul>
</li>
</ul>
<h4 id="6-6-反置页表"><a href="#6-6-反置页表" class="headerlink" title="6.6 反置页表"></a>6.6 反置页表</h4><ul>
<li>把<strong>进程标识ID和页面号加在一起做HASH映射</strong>，查找对应页表项中的帧号.如果对应表中的PID和页号一致就是想要查找的对应项.</li>
</ul>
<h4 id="6-7-段页式存储管理"><a href="#6-7-段页式存储管理" class="headerlink" title="6.7 段页式存储管理"></a>6.7 段页式存储管理</h4><ul>
<li>在段式存储管理基础上,给每个段加一级页表</li>
<li>可以通过指向相同的页表基址, 实现进程间的段共享.</li>
<li>过程简要描述:<ul>
<li>逻辑地址有指定的位数长度用于存储段的偏移, 一定位数用于存储段中的页表的偏移, 最后存储页面的偏移. 通过STBR+段表偏移, 找到对应的段表项, 段表项中描述了对应的页表的基址, 查询到页表的基址后 加上段对应的页表的偏移找到对应的页表项. 页表项中描述了对应的页帧号, 通过页帧号加上页面偏移就可以得到最后的页了.</li>
</ul>
</li>
</ul>
<h3 id="第七讲-实验二-物理内存管理"><a href="#第七讲-实验二-物理内存管理" class="headerlink" title="第七讲 实验二 物理内存管理"></a>第七讲 实验二 物理内存管理</h3><h3 id="第八讲-虚拟存储概念"><a href="#第八讲-虚拟存储概念" class="headerlink" title="第八讲 虚拟存储概念"></a>第八讲 虚拟存储概念</h3><h4 id="8-1-虚拟存储的需求背景"><a href="#8-1-虚拟存储的需求背景" class="headerlink" title="8.1 虚拟存储的需求背景"></a>8.1 虚拟存储的需求背景</h4><ul>
<li>虚拟存储时在非连续内存分配的基础上，<strong>可以把一部分的内容放到外存里的做法</strong>。由操作系统来做，又不是以整个进程为单位，是一部分一部分的，进程空间的一部分内容导入到外存里头去。</li>
</ul>
<h4 id="8-2-覆盖和交换"><a href="#8-2-覆盖和交换" class="headerlink" title="8.2 覆盖和交换"></a>8.2 覆盖和交换</h4><ul>
<li>覆盖 （在较小的可用内存中运行较大的程序）<ul>
<li>方法：<ul>
<li>依据程序逻辑结构，将程序划分为若干<strong>功能相对独立</strong>的模块，将不会同时执行的模块<strong>共享同一块内存区域</strong>。</li>
<li>必要部分（常用部分）的代码和数据常驻内存</li>
<li>可选部分（不常用部分）放在其他程序模块中，只在需要用到时装入内存</li>
</ul>
</li>
<li>只能发生再没有调用关系的模块间</li>
<li>给出的时模块间的逻辑覆盖结构</li>
<li>发生在运行程序的内部模块间</li>
<li>不同的非必须模块在需要的时候才加载到同一个内存空间中，实现相应的覆盖功能。</li>
</ul>
</li>
<li>交换（不讨论一个程序在所有内存空间里用的时候它仍然不够的情况）<ul>
<li>实现方法：<ul>
<li><strong>可将暂时不能运行的程序放到外存</strong></li>
<li>可换入换出的基本单位<ul>
<li>整个进程的地址空间</li>
</ul>
</li>
<li>换出（swap out）<ul>
<li>把一个进程的整个地址空间保存到外存</li>
</ul>
</li>
<li>换入(swap in)<ul>
<li>把外存中某进程的地址空间读入到内存</li>
</ul>
</li>
</ul>
</li>
<li>以进程为单位</li>
<li>不需要模块间的逻辑覆盖结构</li>
<li>发生在内存进程间</li>
</ul>
</li>
</ul>
<h4 id="8-3-局部性原理（principle-of-locality）"><a href="#8-3-局部性原理（principle-of-locality）" class="headerlink" title="8.3 局部性原理（principle of locality）"></a>8.3 局部性原理（principle of locality）</h4><ul>
<li>程序在执行过程中的一个<strong>较短时期</strong>，所执行的指令地址和指令的操作数地址，分别局限于一定区域。<ul>
<li>时间局部性<ul>
<li>一条<strong>指令</strong>的一次执行和下次执行，一个<strong>数据</strong>的一次访问和下次访问都几种在一个较短的时期内。</li>
</ul>
</li>
<li>空间局部性<ul>
<li>当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。eg. 比如说对数据进行排序的过程中，循环操作和对应的数据。</li>
</ul>
</li>
<li>分支局部性<ul>
<li>一条跳转指令的两次执行，很可能跳到相同的内存位置。eg. 比如说有一个循环，没到循环次数都要跳转到开头的位置。</li>
</ul>
</li>
</ul>
</li>
<li>局部性原理的意义<ul>
<li>从理论上来说，虚拟存储技术是能够实现的，而且可以取得满意的效果。</li>
</ul>
</li>
</ul>
<h4 id="8-4-虚拟存储概念"><a href="#8-4-虚拟存储概念" class="headerlink" title="8.4 虚拟存储概念"></a>8.4 虚拟存储概念</h4><ul>
<li><p>思路：</p>
<ul>
<li>将不常用的部分内存暂存到外存</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li>装载程序时<ul>
<li>只将当前指令执行需要的部分页面或段装入内存</li>
</ul>
</li>
<li>指令执行中需要的指令或数据不在内存（称为缺页或缺段）时<ul>
<li>处理器通知操作系统将相应的页面或段调入内存</li>
</ul>
</li>
<li>操作系统将内存中暂时不用的页面或段保存到外存</li>
</ul>
</li>
<li><p>实现方式</p>
<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
</li>
<li><p>虚拟存储的基本特征</p>
<ul>
<li><strong>不连续性</strong><ul>
<li>物理地址分配非连续</li>
<li>虚拟地址空间使用非连续</li>
</ul>
</li>
<li><strong>大用户空间</strong><ul>
<li>提供给用户的虚拟内存可大于实际的物理内存</li>
</ul>
</li>
<li><strong>部分交换</strong><ul>
<li>虚拟存储只对部分虚拟地址空间进行调入和调出</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟存储的技术支持</p>
<ul>
<li>硬件<ul>
<li>页式或段式存储中的地址转换机制</li>
</ul>
</li>
<li>操作系统<ul>
<li>管理内存和外存间页面或段的换入和换出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-5-虚拟页式存储"><a href="#8-5-虚拟页式存储" class="headerlink" title="8.5 虚拟页式存储"></a>8.5 虚拟页式存储</h4><ul>
<li>在页式存储管理的基础上，增加请求调页和页面置换</li>
<li>思路<ul>
<li><strong>当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行</strong></li>
<li>进程在运行中发现有需要的代码或数据不再内存时，则向系统发出缺页异常请求</li>
<li>操作系统在处理缺页异常时，将外存中相应的页面调入内存使得进程能继续运行</li>
</ul>
</li>
<li>主要实现过程和前面的页式管理大致相同，不同的在于页表项中添加了一些相应的标志位，这些标志位用于虚拟内存的相关操作。</li>
<li>相应页表项结构中的一些位的说明：<ul>
<li><strong>驻留位</strong>：表示该页是否在内存<ul>
<li>1表示该页位于内存中，该页表项是有效的，可以使用</li>
<li>0表示该页当前在外存中，访问该页表项将导致缺页异常</li>
</ul>
</li>
<li><strong>修改位</strong>：表示在内存中的该页是否被修改过<ul>
<li>回收该物理页面时，据此判断是否要把它的内容写回外存。如果修改过，放到外存中必须写回到外存。没有修改过的话，替换和置换的时候只需要把这一页作废就行。</li>
</ul>
</li>
<li><strong>访问位</strong>：表示该页面是否被访问过（读或写）<ul>
<li>用于页面置换算法（近似地统计出来这一页是否被经常访问）</li>
</ul>
</li>
<li><strong>保护位</strong>：表示该页地允许访问方式<ul>
<li>只读、可读写、可执行等</li>
</ul>
</li>
<li><strong>用户态标志U</strong>：表示是否可以在用户态还是内核态访问</li>
</ul>
</li>
</ul>
<h4 id="8-6-缺页异常"><a href="#8-6-缺页异常" class="headerlink" title="8.6 缺页异常"></a>8.6 缺页异常</h4><ul>
<li>大致处理流程：<ul>
<li>CPU里面访问一条指令，找到对应的页表项，如果这一页是有效的或者驻留位为1，就可以直接访问。如果这一页无效就会产生缺页异常，导致操作系统的缺页异常服务例程的执行。在缺页异常服务例程中，查找对应的一页在外存中存在的位置，找到的话就读到内存里头来。寻找物理内存中的空闲页帧，找到的话就修改对应的页表项，修改完成后再重新执行这条指令。<ul>
<li>A. 在内存中有空闲物理页面时，分配一物理页帧f，转到E步；</li>
<li>B. 依据页面置换算法选择将被替换的物理页帧f，对应逻辑页面q</li>
<li>C. 如果被修改过，则把它写回外存；</li>
<li>D. 修改q的页表项中驻留位置为0;</li>
<li>E. 将需要访问的页p装入到物理页面f</li>
<li>F. 修改p的页表驻留位为1，物理页帧号为f;</li>
<li>G. 重新执行产生缺页的指令</li>
</ul>
</li>
</ul>
</li>
<li>虚拟页式存储中的外存管理<ul>
<li><strong>在何处保存未被映射的页</strong>？（一个兑换区）<ul>
<li>应能方便地找到在外存中的页面内容</li>
<li>交换空间（磁盘或者文件夹）<ul>
<li>采用特殊格式存储未被映射的页面</li>
</ul>
</li>
</ul>
</li>
<li>虚拟页式存储中的外存选择<ul>
<li>代码段：可执行二进制文件</li>
<li>动态加载的共享库程序段：动态调用的库文件</li>
<li>其他段：交换空间（比如说数据段、堆栈段）</li>
</ul>
</li>
</ul>
</li>
<li>性能指标：<ul>
<li>有效存储访问时间（effective memory access time）</li>
<li>EAT = 访存时间 * (1 - p) + 缺页异常处理时间 * 缺页率p</li>
</ul>
</li>
</ul>
<h3 id="第九讲-页面置换算法"><a href="#第九讲-页面置换算法" class="headerlink" title="第九讲 页面置换算法"></a>第九讲 页面置换算法</h3><h4 id="9-1-页面置换算法的概念"><a href="#9-1-页面置换算法的概念" class="headerlink" title="9.1 页面置换算法的概念"></a>9.1 页面置换算法的概念</h4><ul>
<li>置换算法的功能和目标<ul>
<li>在虚拟存储系统当中，出现缺页的时候，需要把一个新的页面换入到内存当中来，当这时候内存中的页面全部用完了，要选择一个页面到外面去，才能把新的页面放入。简单来说，当出现缺页异常，需调入新页面而内存已满时，置换算法<strong>选择被置换的物理页面</strong></li>
<li>设计目标<ul>
<li>尽可能<strong>减少页面的调入调出次数</strong></li>
<li>把未来不再访问或短期内不访问的页面调出</li>
</ul>
</li>
<li>页面锁定（frame locking）<ul>
<li>描述必须常驻内存的逻辑页面</li>
<li>操作系统的关键部分</li>
<li>要求响应速度的代码和数据</li>
<li>页表中的锁定标志位（lock bit）</li>
</ul>
</li>
</ul>
</li>
<li>局部页面置换算法<ul>
<li>置换页面的选择范围仅限于<strong>当前进程</strong>占用的物理页面内</li>
<li>最优算法、先进先出算法、最近最久未使用算法</li>
<li>时钟算法、最不常用算法</li>
</ul>
</li>
<li>全局页面置换算法<ul>
<li>置换页面的选择范围时所有可换出的物理页面</li>
<li>工作集算法、缺页率算法</li>
</ul>
</li>
</ul>
<h4 id="9-2-最优算法、先进先出算法和最近最久未使用算法"><a href="#9-2-最优算法、先进先出算法和最近最久未使用算法" class="headerlink" title="9.2 最优算法、先进先出算法和最近最久未使用算法"></a>9.2 最优算法、先进先出算法和最近最久未使用算法</h4><ul>
<li>最优置换算法（OPT，optimal）<ul>
<li>基本思路<ul>
<li>置换在未来最长时间不访问的页面</li>
</ul>
</li>
<li>算法实现<ul>
<li>缺页时，计算内存中每个逻辑页面的下一次访问时间</li>
<li>选择<strong>未来最长时间不访问的页面</strong></li>
</ul>
</li>
<li>算法特征<ul>
<li>缺页最少，是理想情况</li>
<li>实际系统中无法实现</li>
<li>无法预知每个页面在下次访问前的等待时间</li>
<li>作为置换算法的性能评价依据<ul>
<li>在模拟器上运行某个程序，并记录每一次的页面访问情况</li>
<li>第二遍运行时使用最优算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>先进先出算法（First-In First-Out, FIFO）<ul>
<li>思路：<ul>
<li>选择<strong>在内存驻留时间最长</strong>的页面进行置换</li>
</ul>
</li>
<li>实现<ul>
<li>维护一个记录所有位于内存中的逻辑页面链表</li>
<li>链表元素<strong>按驻留内存的时间排序</strong>，链首最长，链尾最短</li>
<li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li>
</ul>
</li>
<li>特征<ul>
<li>实现简单</li>
<li>性能较差，调出的页面可能时经常访问的</li>
<li>进程分配物理页面增加时，缺页并不一定减少（Belady）现象。</li>
<li>很少单独使用</li>
</ul>
</li>
</ul>
</li>
<li>最近最久未使用算法（Least Recently Used LRU）<ul>
<li>思路<ul>
<li>选择<strong>最长时间没有被引用</strong>的页面进行置换</li>
<li>如某些页面长时间未被访问，则它们在将来还可能会长时间不会访问</li>
<li>看过去的访问情况</li>
</ul>
</li>
<li>实现<ul>
<li>缺页时，计算内存中每个逻辑页面的<strong>上一次</strong>访问时间</li>
<li>选择<strong>上一次使用到当前时间最长的页面</strong></li>
</ul>
</li>
<li>特征<ul>
<li>最优置换算法的一种近似。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-3-时钟置换算法和最不常用算法"><a href="#9-3-时钟置换算法和最不常用算法" class="headerlink" title="9.3 时钟置换算法和最不常用算法"></a>9.3 时钟置换算法和最不常用算法</h4><ul>
<li>时钟置换算法<ul>
<li>思路<ul>
<li><strong>仅对页面的访问情况进行大致统计</strong></li>
</ul>
</li>
<li>数据结构<ul>
<li>在页表项中增加<strong>访问位</strong>，描述页面在过去一段时间的内访问情况</li>
<li>各页面组织成<strong>环形链表</strong></li>
<li><strong>指针</strong>指向最先调入的页面</li>
</ul>
</li>
<li>算法<ul>
<li>访问页面时，在页表项记录页面访问情况</li>
<li>缺页时，从指针处开始顺序查找未被访问的页面进行置换</li>
<li>页面装入内存时，访问初始化为0</li>
<li>访问页面（读/写）时，访问位置1</li>
<li>缺页时，从指针当前位置顺序检查环形链表<ul>
<li>访问位为0，则置换该页</li>
<li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面</li>
</ul>
</li>
</ul>
</li>
<li>特征<ul>
<li>时钟算法是LRU和FIFO的折中</li>
</ul>
</li>
</ul>
</li>
<li>改进的Clock算法<ul>
<li>减少修改页的缺页处理开销</li>
<li>算法<ul>
<li>在页面中增加修改位，并在访问时进行相应修改</li>
<li>缺页时，修改页面标志位，以跳过有修改的页面</li>
</ul>
</li>
</ul>
</li>
<li>最不常用算法（Least Frequently Used LFU）<ul>
<li>思路：<ul>
<li>缺页时，置换访问次数最少的页面</li>
</ul>
</li>
<li>实现：<ul>
<li>每个页面设置一个访问计数</li>
<li><strong>访问页面时，访问计数加1</strong></li>
<li>缺页时，置换计算最小的页面</li>
</ul>
</li>
<li>LRU和LFU的区别：<ul>
<li>LRU关注<strong>多久未访问</strong>，时间越短越好</li>
<li>LFU关注<strong>访问次数</strong>，次数越过越好。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-4-Belady现象和局部置换算法比较"><a href="#9-4-Belady现象和局部置换算法比较" class="headerlink" title="9.4 Belady现象和局部置换算法比较"></a>9.4 Belady现象和局部置换算法比较</h4><ul>
<li>Belady现象：<ul>
<li>采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象。</li>
</ul>
</li>
<li>原因：<ul>
<li>FIFO算法的置换特征与进程访问内存的动态特征矛盾</li>
<li>被它置换出去的页面并不一定时进程近期不会访问的</li>
</ul>
</li>
<li>LRU算法没有Belady现象</li>
<li>LRU算法可以退化成FIFO算法</li>
<li>对于未被访问的页面，Clock和LRU算法的表现一样好</li>
<li>对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以</li>
</ul>
<h4 id="9-5-工作集置换算法（全局置换算法）"><a href="#9-5-工作集置换算法（全局置换算法）" class="headerlink" title="9.5 工作集置换算法（全局置换算法）"></a>9.5 工作集置换算法（全局置换算法）</h4><ul>
<li><p>考虑到不同的内存之间对需求量的差异，局部置换算法没有考虑进程访存差异</p>
</li>
<li><p>全局置换算法：</p>
<ul>
<li>思路：<ul>
<li><strong>全局置换算法为进程分配可变数目的物理页面</strong></li>
</ul>
</li>
<li>全局置换算法要解决的问题<ul>
<li>进程在不同阶段的内存需求是变化的</li>
<li>分配给进程的内存页需要在不同阶段有所变化</li>
<li>全局置换算法需要确定分配给进程的物理页面数</li>
</ul>
</li>
<li>CPU利用率与并发进程数存在相互促进和制约的关系<ul>
<li>进程数少时，提高并发进程数，可提高CPU利用率</li>
<li>并发进程导致内存访问增加</li>
<li>并发进程的内存访问降低了访存的局部性特征</li>
<li>局部性特征的下降会导致缺页率上升和CPU利用率下降</li>
</ul>
</li>
</ul>
</li>
<li><p>一个进程当前正在使用的逻辑页面集合称为（工作集），可表示为二元函数W(t, san)。</p>
<ul>
<li>t是当前大执行时刻</li>
<li>san称为工作集窗口，即一个定长的页面访问时间窗口</li>
<li>W(t, san)是指在当前时刻t前的san时间窗口中的所有访问页面所组成的集合</li>
<li>|W(t, san)|指工作集的大小，即页面数目</li>
</ul>
</li>
<li><p>工作集想要实现的变化</p>
<ul>
<li>进程开始执行后， 随着访问新页面逐步建立较稳定的工作集</li>
<li>当内存访问的局部性区域的位置<strong>大致稳定</strong>时，工作集大小也大致稳定</li>
<li>局部性区域的位置改变时，工作集<strong>快速扩张和收缩</strong>过渡到下一个稳定值</li>
</ul>
</li>
<li><p><strong>引入常驻集的概念：在当前时刻，进程实际驻留在内存当中的页面集合</strong></p>
</li>
<li><p>工作集和常驻集的关系：</p>
<ul>
<li>工作集是进程在运行过程中固有的性质</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法</li>
</ul>
</li>
<li><p>工作集置换算法：</p>
<ul>
<li>思路：<ul>
<li>换出不再工作集的页面</li>
</ul>
</li>
<li>窗口大小w<ul>
<li>当前时刻前w个内存访问的页引用时工作集，w被称为窗口大小。</li>
</ul>
</li>
<li>实现方法：<ul>
<li>访存链表：维护窗口内的访存页面链表。</li>
<li>访存时，换出不再工作集的页面；更新访存链表。</li>
<li>缺页时，换入页面，更新访存链表。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-6-缺页率置换算法"><a href="#9-6-缺页率置换算法" class="headerlink" title="9.6 缺页率置换算法"></a>9.6 缺页率置换算法</h4><ul>
<li>缺页率：缺页平均时间间隔的倒数</li>
<li><strong>通过调节常驻集大小，使每个进程的缺页率保持在一定的范围内</strong><ul>
<li>若进程缺页率过高，则增加常驻集以分配更多的页面</li>
<li>若进程缺页率过低，则减少常驻集以减少它的物理页面</li>
</ul>
</li>
<li>算法的实现：<ul>
<li>访存时，设置引用位标志</li>
<li>缺页时，计算从上次缺页时间t<sub>last</sub>到现在t<sub>current</sub>的时间间隔<ul>
<li>如果t<sub>current</sub>-t<sub>last</sub>&gt;T，则置换所有在[tlast, tcurrent]时间内没有被引用的页</li>
<li>如果t<sub>current</sub>-t<sub>last</sub>&lt;=T，则增加缺失页到常驻集中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-7-抖动和负载控制"><a href="#9-7-抖动和负载控制" class="headerlink" title="9.7 抖动和负载控制"></a>9.7 抖动和负载控制</h4><ul>
<li>抖动：<ul>
<li>进程物理页面太少，不能包含工作集</li>
<li>造成大量缺页，频繁置换</li>
<li>进程运行速度变慢</li>
<li>产生抖动的原因：<ul>
<li><strong>随着驻留内存的进程数增加，分配给每个进程的物理页面数不断减少，缺页率上升</strong></li>
</ul>
</li>
<li>操作系统需要在并发水平和缺页率之间达到一个平衡：<ul>
<li>选择一个适当的进程数目和进程需要的物理页面数目</li>
</ul>
</li>
</ul>
</li>
<li>负载控制<ul>
<li>通过调节并发进程数（MPL）来进行系统负载控制<ul>
<li>内存的大小</li>
<li>平均缺页间隔时间（MTBF）/缺页异常处理时间（PFST）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第十一讲-进程和线程"><a href="#第十一讲-进程和线程" class="headerlink" title="第十一讲 进程和线程"></a>第十一讲 进程和线程</h3><h4 id="11-1-进程的概念"><a href="#11-1-进程的概念" class="headerlink" title="11.1 进程的概念"></a>11.1 进程的概念</h4><ul>
<li>进程是指一个具有一定<strong>独立功能</strong>的程序在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>的过程</li>
<li>进程包含了正在运行的一个程序的所有状态信息：<ul>
<li>代码、数据、状态寄存器、通用寄存器、进程占用资源等</li>
</ul>
</li>
<li>进程的特点：<ul>
<li>动态性：一个程序在执行的过程中，由创建到结束的这个过程</li>
<li>并发性：进程可以被独立调度并占用CPU运行</li>
<li>独立性：不同进程之间的工作相互不影响</li>
<li>制约性：因访问共享数据/资源或进程同步而产生制约</li>
</ul>
</li>
<li>在时间轴上是交替执行的，宏观上是并发执行的。</li>
<li>进程是操作系统处于执行状态程序的抽象<ul>
<li>程序 = 文件(静态的可执行文件)</li>
<li>进程 = 执行中的程序 = 程序 + 执行状态</li>
</ul>
</li>
<li>同一个程序的多次执行过程对应为不同进程<ul>
<li>如命令“ls”的多次执行对应多个进程</li>
</ul>
</li>
<li>进程执行需要的资源<ul>
<li>内存：保存代码和数据</li>
<li>CPU：执行指令</li>
</ul>
</li>
<li>进程是动态的，程序是静态的<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行，进程有核心态/用户态</li>
</ul>
</li>
<li>进程是暂时的，程序是永久的<ul>
<li>进程是一个状态变化的过程</li>
<li>程序可长久保存</li>
</ul>
</li>
<li>进程与程序的组成不同<ul>
<li>进程的组成包括程序、数据和进程控制块</li>
</ul>
</li>
</ul>
<h4 id="11-2-进程控制块（PCB，-Process-Control-Block）"><a href="#11-2-进程控制块（PCB，-Process-Control-Block）" class="headerlink" title="11.2 进程控制块（PCB， Process Control Block）"></a>11.2 进程控制块（PCB， Process Control Block）</h4><ul>
<li>含义：操作系统管理控制进程运行所用的信息集合<ul>
<li>比如说ID、执行的是哪个程序、运行变化的过程</li>
</ul>
</li>
<li><strong>PCB是进程存在的唯一标志</strong>（只要创建了存在了就一定有一个相对应的）<ul>
<li>每个进程都在操作系统中有一个对应的PCB</li>
</ul>
</li>
<li>进程创建<ul>
<li>生成该进程的PCB</li>
</ul>
</li>
<li>进程终止<ul>
<li>回收它的PCB</li>
</ul>
</li>
<li>进程的组织管理<ul>
<li>通过对PCB的管理来实现</li>
</ul>
</li>
<li>进程控制块包含的信息有：<ul>
<li>进程标识信息</li>
<li>处理机现场保存</li>
<li>进程控制信息</li>
</ul>
</li>
<li>把进程地址空间中抽出一部分信息（PC、SP等）放在进程控制块里头。</li>
<li>进程控制信息包含：<ul>
<li>调度和状态信息<ul>
<li>调度进程和处理机使用情况</li>
</ul>
</li>
<li>进程间通信信息<ul>
<li>进程间通信相关的各种标识（读入不同的数据进行处理）</li>
</ul>
</li>
<li>存储管理信息<ul>
<li>指向进程映像存储空间数据结构</li>
</ul>
</li>
<li>进程所用资源<ul>
<li>进程使用的系统资源，如打开文件等</li>
</ul>
</li>
<li>有关数据结构连接信息<ul>
<li>与PCB相关的进程队列</li>
</ul>
</li>
</ul>
</li>
<li>进程控制块的组织<ul>
<li>链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表<ul>
<li>各状态的进程形成不同的链表： 就绪链表、阻塞链表</li>
</ul>
</li>
<li>索引表：同一状态的进程归入一个索引表（由索引指向PCB），多个状态对应多个不同的索引表<ul>
<li>各状态的进行形成不同的索引表：就绪索引表、阻塞索引表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-3-进程状态"><a href="#11-3-进程状态" class="headerlink" title="11.3 进程状态"></a>11.3 进程状态</h4><ul>
<li><p>引起进程创建的情况</p>
<ul>
<li>系统初始化</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
</li>
<li><p>内核选择一个就绪的进程，让它占用处理机并执行</p>
</li>
<li><p>进程进入等待（阻塞）的情况）：</p>
<ul>
<li><p>请求并等待系统服务，无法马上完成（比如说读写磁盘）</p>
</li>
<li><p>启动某种操作，无法马上完成</p>
</li>
<li><p>需要的数据没有到达</p>
<p><strong>只有进程自身才能知道何时需要等待某种事件的发生</strong></p>
</li>
</ul>
</li>
<li><p>进程会被抢占的情况</p>
<ul>
<li>高优先级进程就绪</li>
<li>进程执行当前时间用完（时间片）</li>
</ul>
</li>
<li><p>唤醒进程的情况：</p>
<ul>
<li><p>被阻塞进程需要的资源可被满足</p>
</li>
<li><p>被阻塞进程等待的时间到达</p>
<p><strong>进程只能被别的进程或操作系统唤醒</strong>，不会由于自身的原因直接回去。</p>
</li>
</ul>
</li>
<li><p>进程上下文：</p>
<ul>
<li>是进程执行活动全过程的静态描述。包括计算机系统中与执行该进程有关的各种寄存器的值、对应的堆栈值和PCB结构。可按一定的执行层次组合，如用户级上下文、系统级上下文等。</li>
</ul>
</li>
</ul>
<h4 id="11-4-三状态进程模型"><a href="#11-4-三状态进程模型" class="headerlink" title="11.4 三状态进程模型"></a>11.4 三状态进程模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">创建--&gt;就绪;</span><br><span class="line">就绪--&gt;运行;</span><br><span class="line">运行--&gt;就绪;</span><br><span class="line">等待--&gt;就绪;</span><br><span class="line">运行--&gt;等待;</span><br><span class="line">运行--&gt;退出;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>运行状态(Running)<ul>
<li>进程正在处理机上运行</li>
</ul>
</li>
<li>就绪状态(Ready)<ul>
<li>进程获得了除处理机之外的所需资源，得到处理机即可运行</li>
</ul>
</li>
<li>等待状态（又称阻塞状态Blocked）<ul>
<li>进程正在等待某一事件的出现而暂停运行</li>
</ul>
</li>
<li>创建状态（New）<ul>
<li>一个进程正在被创建，还没被转到就绪状态之前的状态</li>
</ul>
</li>
<li>结束状态（Exit）<ul>
<li>一个进程正在从系统中消失时的专改，这是因为进程结束或由于其他原因所导致。</li>
</ul>
</li>
</ul>
<h4 id="11-5-进程挂起"><a href="#11-5-进程挂起" class="headerlink" title="11.5 进程挂起"></a>11.5 进程挂起</h4><ul>
<li>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存</li>
<li>等待挂起状态（Blocked-suspend）<ul>
<li>进程在外存并等待某事件出现</li>
</ul>
</li>
<li>就绪挂起状态（Ready-suspend）<ul>
<li>进程在外存，但只要进入内存，即可运行</li>
</ul>
</li>
<li>状态队列：<ul>
<li>由操作系统来维护一组队列，表示系统中所有进程的当前状态</li>
<li>不同队列表示不同状态<ul>
<li>就绪队列、各种等待队列</li>
</ul>
</li>
<li>根据进程状态不同，进程PCB加入相应的队列<ul>
<li>进程状态变化时，它所在的PCB会从一个队列换到另一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-6-线程的概念"><a href="#11-6-线程的概念" class="headerlink" title="11.6 线程的概念"></a>11.6 线程的概念</h4><ul>
<li><h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3></li>
</ul>
<p>加电之后去读BIOS，BIOS去读对应的加载程序，加载程序去读对应的内核映像。</p>
<p>系统调用:  INT和IRET指令用于系统调用：系统调用时，堆栈切换和特权级的转换。</p>
<p>函数调用：CALL和RET用于常规调用：常规调用时，没有堆栈切换</p>
<h5 id="文件句柄："><a href="#文件句柄：" class="headerlink" title="文件句柄："></a>文件句柄：</h5><p>1.只有windows中才有句柄，windows中的句柄是指针的指针，因为windows中对象的经常会在内存中移动（如进行垃圾回收后），所以地址值经常会变，所以就对外提供一个指针的指针即句柄给用户，句柄的地址是不会变的。</p>
<p>2.linux中是没有文件句柄的，只有文件描述符，只是大家习惯把它说成句柄。</p>
<p>3。linux中， 每当进程打开一个文件时，系统就为其分配一个唯一对应的整型文件描述符（从0开始），用来标识这个文件。linux 操作系统通常对每个进程能打开的文件数量有一个限制。默认是1024。</p>
<h3 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h3><ul>
<li>首先在CPU加电之后，CPU里面的ROM存储器会将其里面保存的初始值传给各个寄存器，其中CS:IP=0xf000:ffff0(CS: 代码寄存器；IP：指令寄存器)，这个值决定了我们从内存中读数据的位置，PC=16*CS +IP。</li>
<li>此时系统处于实模式，此时的地址总线只有20位，所以地址空间的总大小只有1M，BIOS启动固件就在这个IM的空间里面。</li>
<li>BIOS启动固件提供的一些功能：<ul>
<li>基本输入输出的程序</li>
<li>系统设置信息</li>
<li>开机后自检程序</li>
<li>系统自启动程序</li>
</ul>
</li>
</ul>
<h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>基本格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">    	<span class="string">&quot;addl %2 %0&quot;</span> </span><br><span class="line">        : <span class="string">&quot;=g&quot;</span>(c)</span><br><span class="line">        : <span class="string">&quot;0&quot;</span>(a), <span class="string">&quot;g&quot;</span>(b)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内联汇编中：</p>
<ol>
<li><p>第一行是汇编语句，用双引号引起来，<strong>多条语句使用;或者\n\t来分隔</strong>。</p>
</li>
<li><p>第二行是输出操作数，都是“=？”（var）的形式，var可以是任意内存变量（输出结果会存到这个变量中），？一般是下面这些标识符（表示内联汇编中用什么来代理这个操作数）：</p>
<ol>
<li>a,b,c,d,S,D分别代表eax,ebx,ecx,edx,esi,edi寄存器</li>
<li>r表示上面的任意寄存器的一个（谁空闲就使用谁）</li>
<li>m 内存</li>
<li>i 立即数（常量，只用于输入操作数）</li>
<li>g 寄存器、内存、立即数都行</li>
</ol>
<p><strong>在汇编中使用%序号来表示这些输入/输出操作数，序号从0开始。为了与操作数区分开来，寄存器用两个%引出，如：%%eax</strong></p>
</li>
<li><p>第三行是输入操作数，都是”?“(var)的形式，<strong>？除了可以是上面的那些标识符，还可以是出输出操作数的序号，表示用var来初始化该输出操作数</strong>，上面程序中%0和%1就是一个东西，初始化为1(a的值)。</p>
</li>
</ol>
<h3 id="问题2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#问题2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="问题2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>问题2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h3><ul>
<li>符合规范有两个条件</li>
</ul>
<ol>
<li>主引导扇区应有512Byte</li>
<li>第510，511个字节对应的分别为0x55,0xAA;</li>
</ol>
<h4 id="GDT表"><a href="#GDT表" class="headerlink" title="GDT表"></a>GDT表</h4><p>GDT表的全称是Global Descriptor Table, 中文称作”全局描述符表“。是存在于保护模式下的，GDT表里的每一项被叫做<strong>”段描述符“</strong>，用来记录每个内存分段的一些属性信息，每个”段描述符“占8字节。</p>
<h3 id="第七讲-实验二-物理内存管理-1"><a href="#第七讲-实验二-物理内存管理-1" class="headerlink" title="第七讲 实验二 物理内存管理"></a>第七讲 实验二 物理内存管理</h3><ul>
<li>页目录表的基址是保存在寄存器CR3</li>
<li>在启动页机制后，不可能再取消段机制，因为页机制是需要段机制先有，然后再返回回去，最后实验页机制。进入保护模式后，段机制一定存在，是为了上下兼容。此时，线性地址和虚地址是对等映射。</li>
<li>给定一个虚页地址和物理页地址，再建立二级页表并建立正确虚实映射关系的过程中，需要完成的事务主要包括：<ul>
<li>给页目录表动态分配空间，给页表分配空间</li>
<li>让页基址寄存器的高20位内容位页目录表的高20位物理地址</li>
<li>再虚地址高10位的值为index的页目录项中的高20位填写页表的高20位物理地址，设置有效位</li>
<li>再虚地址中10位的值为index的页表项中的高20位填写物理页地址的高20位物理地址，设置有效位</li>
</ul>
</li>
<li>再保护模式下，x86体系结构中内存地址有三种：逻辑地址（虚地址）、线性地址和物理地址，逻辑地址指的是程序指令中使用的地址，物理地址是实际可以访问的地址。逻辑地址通过段式管理的地址映射方式可以得到线性地址，线性地址通过页式管理的方式（地址映射）可以得到物理地址。再ucore中短时管理只起到了一个过度作用，它将逻辑地址不加转换地直接映射成线性地址。</li>
<li>ucore中地页式管理将线性地址分成三部分（Directory部分、Table部分和Offset部分）。ucore地页式管理通过一个二级地页表实现。一级页表地起始物理地址存放再cr3寄存器中，这个地址必须是一个页对齐地地址，低12位必须为0.</li>
</ul>
<h3 id="第八讲-虚拟存储"><a href="#第八讲-虚拟存储" class="headerlink" title="第八讲 虚拟存储"></a>第八讲 虚拟存储</h3><ul>
<li>时间局部性<ul>
<li>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都几种在一个较短时期内</li>
</ul>
</li>
<li>空间局部性<ul>
<li>当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都几种在一个较小区域内</li>
</ul>
</li>
<li>分支局部性<ul>
<li>一条跳转指令的两次执行，很可能跳到相同的内存位置</li>
</ul>
</li>
</ul>
<h4 id="虚拟存储的基本概念"><a href="#虚拟存储的基本概念" class="headerlink" title="虚拟存储的基本概念"></a>虚拟存储的基本概念</h4><ul>
<li>思路：<ul>
<li>将不常用的部分内存块暂存到外存</li>
</ul>
</li>
<li>原理：<ul>
<li>只将当前指令执行需要的部分页面或段装入内存</li>
<li>指令执行中需要的指令或数据不在内存（称为缺页或缺段）时<ul>
<li>处理器通知操作系统将相应的页面或段调入内存</li>
</ul>
</li>
<li>操作系统将内存中暂时不用的页面或段保存到外存</li>
</ul>
</li>
<li>实现方式<ul>
<li>虚拟页式存储</li>
<li>虚拟段式存储</li>
</ul>
</li>
</ul>
<h3 id="进程的属性与特性解析"><a href="#进程的属性与特性解析" class="headerlink" title="进程的属性与特性解析"></a>进程的属性与特性解析</h3><p>何为进程？：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul>
<li>进程是<strong>资源分配</strong>的基本单位，线程是<strong>独立调度</strong>的基本单位。</li>
</ul>
<p>一个进程拥有一个存放程序和数据的虚拟地址空间以及其他资源。一个进程基于程序的指令流执行，其执行过程可能与其它进程的执行过程交替进行。因此，<strong>一个具有执行状态（运行态、就绪态等）的进程是一个被操作系统分配资源（比如分配内存）并调度（比如分时使用CPU）的单位</strong>。在大多数操作系统中，这两个特点是进程的主要本质特征。但这两个特征相对独立，操作系统可以把这两个特征分别进行管理。</p>
<p>这样可以把拥有资源所有权的单位通常仍称作进程，对资源的管理成为进程管理；把指令执行流的单位称为线程，<strong>对线程的管理就是线程调度和线程分派</strong>。对属于同一进程的所有线程而言，这些线程共享进程的虚拟地址空间和其他资源，但每一个线程都有一个独立的栈，还有独立的线程运行上下文，用于包含表示线程执行现场的寄存器值等信息。</p>
<p>在多线程环境中，进程被定义成资源分配与保护的单位，与进程相关联的信息主要又存放进程映像的虚拟地址空间等。在一个进程中，可能又一个或多个线程，每个线程又线程执行状态（运行、就绪、等待等），保存上次运行时的线程上下文、线程的执行等。考虑到CPU有不同的特权模式，参数进程的分类，线程又可进一步细化为用户线程和内核线程。<strong>从本质上看，线程就是一个特殊的不用拥有资源的轻量级线程</strong>。</p>
<p>从操作系统的设计和实现的角度来看，其实用户进程是指一个应用程序在操作系统提供的一个用户环境中的一次执行过程。基于功能分析，用户环境可以定义为如下组成部分：</p>
<ul>
<li>建立用户虚拟空间的页表和支持页换入换出机制的用户内存访存错误异常服务例程：提供地址隔离和超过物理空间大小的虚拟空间。</li>
<li>应用程序执行用户态CPU特权级：在用户态CPU特权级，用户只能执行一般指令，如果是特权指令，结果不是无效就是产生“执行非法指令”异常。</li>
<li>系统调用机制：给用户进程提供“服务窗口”；</li>
<li>中断响应机制：给用户进程设置“中断窗口”，这样产生中断后，当前执行的用户进程将被强制打断，CPU控制权将被操作系统的中断服务例程使用。</li>
</ul>
<h4 id="一个问题：为何不让进程本身完成所有的资源回收工作呢？"><a href="#一个问题：为何不让进程本身完成所有的资源回收工作呢？" class="headerlink" title="一个问题：为何不让进程本身完成所有的资源回收工作呢？"></a>一个问题：为何不让进程本身完成所有的资源回收工作呢？</h4><ul>
<li>因为进程要执行回收操作，就表明此进程还存在，还在执行指令，这就需要内核栈的空间不能释放，且表示进程存在的进程控制块不能释放。所以需要父进程来帮忙释放子进程无法完成的这两个资源回收工作。</li>
</ul>
<p>需要一种机制来确保用户进程不能执行特权指令，但能够请操作系统“帮忙”完成需要特权指令的任务，这种机制就是系统调用。这样子的好处有几点：</p>
<ul>
<li>简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统来实现，但提供一个简洁的接口给进程调用；</li>
<li>接口可以事先规定好，严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</li>
</ul>
<h3 id="第十五讲"><a href="#第十五讲" class="headerlink" title="第十五讲"></a>第十五讲</h3><h4 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h4><ul>
<li>调度算法主要有以下几种：<ul>
<li>先来先服务算法<ul>
<li>不公平，平均等待时间较差</li>
</ul>
</li>
<li>短进程优先算法<ul>
<li>不公平，平均周转时间最小</li>
<li>需要精确预测计算时间</li>
<li>可能导致饥饿</li>
</ul>
</li>
<li>最高响应比优先算法<ul>
<li>基于SPN调度</li>
<li>不可抢占</li>
</ul>
</li>
<li>时间片轮转算法<ul>
<li>公平，但是平均等待时间较差</li>
</ul>
</li>
<li>多级反馈队列算法<ul>
<li>多种算法的集成</li>
</ul>
</li>
<li>公平共享调度算法<ul>
<li>公平是第一要素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h4><ul>
<li>P()可能被阻塞，V()不会被阻塞</li>
<li>通常假定信号量是“<strong>公平的</strong>”<ul>
<li>线程不会被无限期阻塞在P()操作中，有一个最长时间，超过就会被清除</li>
<li>假定信号量等待按先进先出排队</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="信号量分类："><a href="#信号量分类：" class="headerlink" title="信号量分类："></a>信号量分类：</h4><ul>
<li>一种是二进制信号量：资源数目为1或0</li>
<li>一种是资源信号量：资源数目为任何非负值</li>
</ul>
<h4 id="临界资源和临界区的差别"><a href="#临界资源和临界区的差别" class="headerlink" title="临界资源和临界区的差别"></a>临界资源和临界区的差别</h4><ul>
<li><p>临界资源：</p>
<p><strong>临界资源是一次仅允许一个进程使用的共享资源</strong>。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等。软件有消息队列，变量，数组，缓冲区等。各个进程间采取互斥方式，实现对这种资源的共享。</p>
</li>
<li><p>每个进程中访问临界资源的那段代码称为<strong>临界区</strong>（criticalsection), 每次只允许一个进程进入临界区，进入后，不允许其他进程进入。<strong>不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的临界区称为相关临界区</strong>。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上映像程序的运行性能。</p>
</li>
</ul>
<h4 id="用信号量实现临界区的互斥访问"><a href="#用信号量实现临界区的互斥访问" class="headerlink" title="用信号量实现临界区的互斥访问"></a>用信号量实现临界区的互斥访问</h4><ul>
<li>必须<strong>成对使用</strong>P()操作和V()操作<ul>
<li>P()操作保证互斥访问临界资源</li>
<li>V()操作在使用后释放临界资源</li>
<li>PV操作<strong>不能次序错误、颠倒和遗漏</strong></li>
</ul>
</li>
</ul>
<h4 id="管程（Moniter）"><a href="#管程（Moniter）" class="headerlink" title="管程（Moniter）"></a>管程（Moniter）</h4><ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待时间出现时恢复</li>
<li>在管程中运行的程序需要一个条件变量（Condition）来约束它。条件变量可以让一个线程等待时让另一个线程进入管程，可以有效防止死锁。</li>
</ul>
<h4 id="管程条件变量的释放方式"><a href="#管程条件变量的释放方式" class="headerlink" title="管程条件变量的释放方式"></a>管程条件变量的释放方式</h4><ul>
<li>Hansen管程：主要用于真实OS和Java中<ul>
<li>在执行的过程中，第一个线程等待，第二个线程运行，当第二个线程的运行过程中满足了第一个线程等待的条件，此时先把第二个线程执行完后再运行第一个线程。</li>
</ul>
</li>
<li>Hoare管程：主要用于教科书中<ul>
<li>在执行的过程中，第一个线程等待，第二个线程运行，当第二个线程的运行过程中满足了第一个线程等待的条件，此时跳动第一个先前等待的第一个线程执行，执行完后，再执行第二个线程。</li>
</ul>
</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><ul>
<li>针对死锁的情况，可以设置不同的顺序拿起刀叉，偶数的先拿左边后拿右边，奇数的先拿右边后拿左边。</li>
</ul>
<h3 id="实验七-同步互斥"><a href="#实验七-同步互斥" class="headerlink" title="实验七 同步互斥"></a>实验七 同步互斥</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul>
<li>互斥时指某一个资源同时只允许一个进程对其进行访问，具有唯一性和排它性，但互斥不用限制进程对资源的访问顺序，即访问可以时无序的。</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li>同步是指在进程间的执行必须严格<strong>按照规定的某种先后次序来运行</strong>，即访问时有序的，这种先后次序取决于要系统完成的任务需求。比如说在进程写资源情况下，进程间要满足互斥条件。在进程都资源情况下，可允许多个进程同时访问资源。</li>
</ul>
<p>在管程中仅仅有互斥操作时不够的，进程可能需要等待某个条件Cond为真才能继续执行。如果采用忙等（busy waiting）方式</p>
<h3 id="第二十讲-死锁和进程通信"><a href="#第二十讲-死锁和进程通信" class="headerlink" title="第二十讲 死锁和进程通信"></a>第二十讲 死锁和进程通信</h3><h4 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h4><ul>
<li><p>何为死锁：</p>
<ul>
<li>在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源 ，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地说，就是两个或多个进程被无限期阻塞、相互等待的一种状态。</li>
</ul>
</li>
<li><p>出现死锁的必要条件</p>
<ul>
<li>互斥<ul>
<li>任何时刻只能由一个进程使用一个资源实例</li>
</ul>
</li>
<li>持有并等待<ul>
<li>进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
</ul>
</li>
<li>非抢占<ul>
<li>资源只能在进程使用后资源释放</li>
</ul>
</li>
<li>循环等待<ul>
<li>存在等待进程集合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>我当前的剩余资源可以满足某一个线程未来的需要，并且这种迭代到最后可以满足所有线程的需要，相当于找到了一个安全序列。</li>
<li></li>
</ul>
<h4 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h4><ul>
<li>信号提供的是一种快速响应的信息，信息量很小。</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul>
<li>两个进程想通讯，在内存里建立了一个临时文件，把数据放在文件里头。</li>
<li></li>
</ul>
<h3 id="第二十一讲-文件系统"><a href="#第二十一讲-文件系统" class="headerlink" title="第二十一讲 文件系统"></a>第二十一讲 文件系统</h3><ul>
<li>操作系统中负责管理和存储可长期保存数据的软件功能模块称为文件系统。</li>
<li></li>
</ul>
<h3 id="第二十二讲-实验八-文件系统"><a href="#第二十二讲-实验八-文件系统" class="headerlink" title="第二十二讲 实验八 文件系统"></a>第二十二讲 实验八 文件系统</h3><ul>
<li>文件</li>
<li>目录项：每一个目录项就是一个文件</li>
<li>索引节点</li>
<li>安装点</li>
</ul>
<p>磁盘调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>liweichao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://git-liweichao.github.io/2021/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="操作系统学习记录">http://git-liweichao.github.io/2021/03/09/操作系统学习记录/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/" rel="prev" title="计算机网络相关知识点记录">
      <i class="fa fa-chevron-left"></i> 计算机网络相关知识点记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/25/LeetCode-Record/" rel="next" title="LeetCode-Record">
      LeetCode-Record <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第一讲 操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89"><span class="nav-number">1.0.1.</span> <span class="nav-text">操作系统定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">第三讲 启动、中断和系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-BIOS-Basic-Input-Output-System"><span class="nav-number">1.1.1.</span> <span class="nav-text">3.1 BIOS(Basic Input  Output System)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">3.2 系统启动流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.3 中断、异常和系统调用比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">3.4 系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%AE%9E%E9%AA%8C%E4%B8%80-bootloader%E5%90%AF%E5%8A%A8ucore"><span class="nav-number">1.2.</span> <span class="nav-text">第四讲 实验一 bootloader启动ucore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.3.</span> <span class="nav-text">第五讲 物理内存管理：连续内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">5.1 计算机体系结构和内存层次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90"><span class="nav-number">1.3.2.</span> <span class="nav-text">5.2 地址空间和地址生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.3.3.</span> <span class="nav-text">5.3 连续内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="nav-number">1.3.4.</span> <span class="nav-text">5.3 碎片整理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F-Buddy-System"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.4 伙伴系统(Buddy System)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">1.4.</span> <span class="nav-text">第六讲 物理内存管理：非连续内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">6.2 段式存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">6.3 页式存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E9%A1%B5%E8%A1%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">6.4 页表概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">6.5 快表和多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.4.5.</span> <span class="nav-text">6.6 反置页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.4.6.</span> <span class="nav-text">6.7 段页式存储管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">第七讲 实验二 物理内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.6.</span> <span class="nav-text">第八讲 虚拟存储概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF"><span class="nav-number">1.6.1.</span> <span class="nav-text">8.1 虚拟存储的需求背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.6.2.</span> <span class="nav-text">8.2 覆盖和交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%88principle-of-locality%EF%BC%89"><span class="nav-number">1.6.3.</span> <span class="nav-text">8.3 局部性原理（principle of locality）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.6.4.</span> <span class="nav-text">8.4 虚拟存储概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">1.6.5.</span> <span class="nav-text">8.5 虚拟页式存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-6-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.6.</span> <span class="nav-text">8.6 缺页异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E8%AE%B2-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">第九讲 页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.7.1.</span> <span class="nav-text">9.1 页面置换算法的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-%E6%9C%80%E4%BC%98%E7%AE%97%E6%B3%95%E3%80%81%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">9.2 最优算法、先进先出算法和最近最久未使用算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.3.</span> <span class="nav-text">9.3 时钟置换算法和最不常用算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-Belady%E7%8E%B0%E8%B1%A1%E5%92%8C%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="nav-number">1.7.4.</span> <span class="nav-text">9.4 Belady现象和局部置换算法比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-5-%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.7.5.</span> <span class="nav-text">9.5 工作集置换算法（全局置换算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-6-%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.6.</span> <span class="nav-text">9.6 缺页率置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.7.</span> <span class="nav-text">9.7 抖动和负载控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.8.</span> <span class="nav-text">第十一讲 进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.8.1.</span> <span class="nav-text">11.1 进程的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%8C-Process-Control-Block%EF%BC%89"><span class="nav-number">1.8.2.</span> <span class="nav-text">11.2 进程控制块（PCB， Process Control Block）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.8.3.</span> <span class="nav-text">11.3 进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-%E4%B8%89%E7%8A%B6%E6%80%81%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.8.4.</span> <span class="nav-text">11.4 三状态进程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-5-%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7"><span class="nav-number">1.8.5.</span> <span class="nav-text">11.5 进程挂起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.8.6.</span> <span class="nav-text">11.6 线程的概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.</span> <span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%EF%BC%9A"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">文件句柄：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.</span> <span class="nav-text">实模式和保护模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-number">1.11.</span> <span class="nav-text">内联汇编</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%982-%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%B3%BB%E7%BB%9F%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83%E7%9A%84%E7%A1%AC%E7%9B%98%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">问题2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GDT%E8%A1%A8"><span class="nav-number">1.12.1.</span> <span class="nav-text">GDT表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E8%AE%B2-%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="nav-number">1.13.</span> <span class="nav-text">第七讲 实验二 物理内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E8%AE%B2-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="nav-number">1.14.</span> <span class="nav-text">第八讲 虚拟存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.1.</span> <span class="nav-text">虚拟存储的基本概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="nav-number">1.15.</span> <span class="nav-text">进程的属性与特性解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.15.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%AE%A9%E8%BF%9B%E7%A8%8B%E6%9C%AC%E8%BA%AB%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E5%B7%A5%E4%BD%9C%E5%91%A2%EF%BC%9F"><span class="nav-number">1.15.2.</span> <span class="nav-text">一个问题：为何不让进程本身完成所有的资源回收工作呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%AE%B2"><span class="nav-number">1.16.</span> <span class="nav-text">第十五讲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">1.16.1.</span> <span class="nav-text">处理机调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.16.2.</span> <span class="nav-text">信号量的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-number">1.16.3.</span> <span class="nav-text">信号量分类：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">1.16.4.</span> <span class="nav-text">临界资源和临界区的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">1.16.5.</span> <span class="nav-text">用信号量实现临界区的互斥访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%88Moniter%EF%BC%89"><span class="nav-number">1.16.6.</span> <span class="nav-text">管程（Moniter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E9%87%8A%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="nav-number">1.16.7.</span> <span class="nav-text">管程条件变量的释放方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">1.16.8.</span> <span class="nav-text">哲学家就餐问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%83-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5"><span class="nav-number">1.17.</span> <span class="nav-text">实验七 同步互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">1.17.1.</span> <span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">1.17.2.</span> <span class="nav-text">同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E8%AE%B2-%E6%AD%BB%E9%94%81%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">1.18.</span> <span class="nav-text">第二十讲 死锁和进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E5%BF%B5"><span class="nav-number">1.18.1.</span> <span class="nav-text">死锁概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.18.2.</span> <span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">1.18.3.</span> <span class="nav-text">进程间的通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">1.18.4.</span> <span class="nav-text">管道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E8%AE%B2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.19.</span> <span class="nav-text">第二十一讲 文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%AE%B2-%E5%AE%9E%E9%AA%8C%E5%85%AB-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.20.</span> <span class="nav-text">第二十二讲 实验八 文件系统</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="liweichao"
      src="/images/clannad.jpg">
  <p class="site-author-name" itemprop="name">liweichao</p>
  <div class="site-description" itemprop="description">If you are not as smart as others, as others good conditions, please put more time! more energy! more sweat!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/git-liweichao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;git-liweichao" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:li_wei_chao@126.com" title="E-Mail → mailto:li_wei_chao@126.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">©2021 by LiWeiChao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":170,"height":340},"mobile":{"show":true,"scale":0.5},"react":{"opacity":1},"log":false});</script></body>

<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>

</html>
